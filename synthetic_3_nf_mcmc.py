import numpy as np

import emcee

import utils

N = 10000

ndims = 2, 4, 6, 10, 15, 20, 25

for ndim in ndims:

    perm = np.random.permutation(N)

    # load samples pre-generated by NF
    samples = utils.pload('data/nf_circle_samples_ndim_' + str(ndim) + '.obj')[:N]#[perm]
    # load NF densities for the samples
    log_prob = utils.pload('data/nf_circle_log_prob_ndim_' + str(ndim) + '.obj')[:N]#[perm]
    # load true posterior values for the samples
    log_post = utils.pload('data/nf_circle_log_post_ndim_' + str(ndim) + '.obj')[:N]#[perm]

    samples, log_prob, log_post = samples[perm], log_prob[perm], log_post[perm]

    ensemble = np.zeros((N, samples.shape[1]))
    history = np.zeros(N)
    densities = np.zeros(N)

    # we accept the first sample by default -> starting value of chain
    m0 = samples[0]
    log_p0 = log_post[0]
    log_q0 = log_prob[0]

    ensemble[0] = m0
    densities[0] = log_p0
    history[0] = 1

    for i in range(N-1):
        # propose next model
        m1, log_p1, log_q1 = samples[i+1], log_post[i+1], log_prob[i+1]

        # toss a coin
        log_alpha = np.log(np.random.uniform())

        # accept or reject
        if log_alpha < log_p1 - log_p0 + log_q0 - log_q1:
            # if accepted, then change state of chain, otherwise keep old one
            m0, log_p0, log_q0 = m1, log_p1, log_q1
            history[i+1] = 1
        else:
            history[i+1] = 0

        # add current sample to the chain
        ensemble[i+1] = m0
        densities[i+1] = log_p0


    utils.psave(ensemble, 'data/nf_circle_mcmc_samples_perc' + str(ndim) + '.obj')
    utils.psave(densities, 'data/nf_circle_mcmc_densities_perc' + str(ndim) + '.obj')
    utils.psave(history, 'data/nf_circle_mcmc_history_perc' + str(ndim) + '.obj')
